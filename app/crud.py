from typing import List, Optional

from fastapi import HTTPException
from app import models
from app import schemas
from app import database
from app.schemas import ToDoCreate
from sqlalchemy.orm import Session

notes = """

ðŸ§  PERSONAL REVELATION â€” WHY CRUD LOGIC MUST BE SEPARATE FROM ROUTES

I didnâ€™t fully understand why logic was moved out of FastAPI routes and into a `crud.py` file,
until I faced a real limitation:

I wanted to insert data into my database directly (e.g., via a script, not by calling an API route).
But because all my DB logic was embedded inside route functions, I couldn't access it without
running the entire FastAPI server.

ðŸ’¡ That's when it clicked: keeping logic in `crud.py` makes it reusable â€” I can call it from:
   - API routes
   - CLI scripts
   - unit tests
   - startup events
   - background tasks

Trying to bypass the API made me understand that logic tied to HTTP routes is not reusable logic.

Now I see:
> ROUTES = glue between the outside world and internal logic  
> CRUD = the actual logic that can be used anywhere

This is more than a coding style â€” it's a foundation for maintainable, testable software.


ðŸ§  TECHNICAL: WHY THIS crud.py FILE EXISTS

The purpose of this module is to separate business logic (e.g., database operations)
from the route definitions (i.e., API endpoints).

This achieves several things:
1. REUSABILITY â€” The same logic can be reused from:
   - FastAPI routes
   - CLI scripts
   - startup/shutdown events
   - unit tests
   - background jobs

2. TESTABILITY â€” You can write focused unit tests for the logic here
   without needing to spin up the entire FastAPI app.

3. DECOUPLING â€” Keeping logic out of route functions avoids tight coupling
   to the HTTP layer and encourages a cleaner, layered architecture.

4. CLARITY â€” Routes should just coordinate the flow: 
   receive input â†’ call logic (from crud) â†’ return result.

TL;DR:
Donâ€™t put logic in your routes â€” put it here. Routes should delegate, not operate.
"""

def create_todo( db: Session, todo_data: ToDoCreate ) -> ToDoCreate:
   todo_item = models.Todo(**todo_data.model_dump())
   db.add(todo_item)
   db.commit()
   db.refresh(todo_item)
   return todo_item

def get_todo( db: Session, todo_id: int ) -> Optional[schemas.ToDoResponse]:
   todo = db.query(models.Todo).filter(models.Todo.id == todo_id).first()
   if not todo:
      raise HTTPException(status_code=404, detail="Todo Item not found")
   return todo

def list_todos( db: Session, skip: int = 0, limit: int = 10 ):
   return db.query(models.Todo).offset(skip).limit(limit).all()

def update_todo( db: Session, todo_id: int, todo_update: schemas.ToDoUpdate ) -> Optional[schemas.ToDoResponse]:
   
   todo_item = db.query(models.Todo).filter(models.Todo.id == todo_id).first()
   
   if not todo_item:
      raise HTTPException(status_code=404, detail="Todo Item not found")
   
   update_data = todo_update.model_dump(exclude_unset=True)
   
   for key, value in update_data.items():
      setattr(todo_item, key, value)
   
   db.commit()
   db.refresh(todo_item)
   
   return todo_item

def delete_todo( db: Session, todo_id: int ) -> Optional[schemas.ToDoResponse]:
   
   todo = db.query(models.Todo).filter(models.Todo.id == todo_id).first()
   
   if not todo:
      raise HTTPException(status_code=404, detail="Todo Item not found")
   
   db.delete(todo)
   db.commit()
   # return todo
   return


# ========== BULK OPERATIONS FOR MULTIPLE INSERTIONS AND DELETIONS =============
def create_many_todos(db: Session, todos_data: List[ToDoCreate]) -> List[models.Todo]:
   
   todo_items = [models.Todo(**todo.model_dump()) for todo in todos_data]
   db.add_all(todo_items)
   db.commit()
   
   # refresh each instance to access autogenerated fields
   for todo in todo_items:
       db.refresh(todo)
   
   return todo_items




# ================ DB SYSTEM SENSITIVE OPERATIONS =====================
# WARNING: TESTING ONLY - DO NOT USE IN PRODUCTION ROUTES
def create_all_tables(engine):
   database.Base.metadata.create_all(bind=engine)
   
def drop_all_tables(engine):
   database.Base.metadata.drop_all(bind=engine)

def reset_database(engine):
   drop_all_tables(engine)
   create_all_tables(engine)

def reset_table(engine, table):
   # Drop and recreate any table
   table.__table__.drop(bind=engine, checkfirst=True)
   table.__table__.create(bind=engine, checkfirst=True)


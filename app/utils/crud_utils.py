
from typing import List
from app import models, schemas
from app.core import database 
from sqlalchemy.orm import Session

# WARNING: TESTING ONLY - DO NOT USE IN PRODUCTION ROUTES
def create_all_tables(engine):
   """
   Creates all tables defined in the SQLAlchemy metadata using the provided engine.

   Args:
      engine: SQLAlchemy engine bound to the target database.

   Notes:
      This operation is database-destructive if followed by `drop_all_tables`. 
      Should only be used for initialization or testing purposes.
   """
   database.Base.metadata.create_all(bind=engine)
   
def drop_all_tables(engine):
   """
   Drops all tables defined in the SQLAlchemy metadata using the provided engine.

   Args:
      engine: SQLAlchemy engine bound to the target database.

   Warning:
      This operation is irreversible and will delete all data and schema definitions. 
      For testing or development use only.
   """
   database.Base.metadata.drop_all(bind=engine)

def reset_database(engine):
   """
   Completely resets the database by dropping and recreating all tables.

   Args:
      engine: SQLAlchemy engine bound to the target database.

   Warning:
      This function destroys all data and schema. Use it strictly in non-production environments 
      such as testing or local development.
   """
   
   drop_all_tables(engine)
   create_all_tables(engine)

# Drop and recreate any table
def reset_table(engine, table):
   """
   Resets a specific table by dropping and recreating it.

   Args:
      engine: SQLAlchemy engine bound to the target database.
      table: SQLAlchemy model class representing the table to be reset.

   Notes:
      Useful for isolated testing or when modifying a specific table's schema during development.
      Existing data in the table will be lost.
   """
   table.__table__.drop(bind=engine, checkfirst=True)
   table.__table__.create(bind=engine, checkfirst=True)

# ========== BULK OPERATIONS FOR MULTIPLE INSERTIONS AND DELETIONS =============
def create_many_users(db: Session, users_data: List[schemas.UserCreate]) -> List[models.User]:
   """
   Bulk creates multiple user objects in the database.

   Args:
      db (Session): SQLAlchemy session object for database access.
      users_data (List[userCreate]): A list of Pydantic userCreate models containing user object data.

   
   Returns:
      List[models.User]: A list of created user model instances with updated fields (e.g., autogenerated IDs).
   
   Notes:
      This operation adds all the user objects to the session, commits the transaction, 
      and refreshes each object to reflect database-generated fields.
   """
   user_objects = [models.User(**user.model_dump()) for user in users_data]
   db.add_all(user_objects)
   db.commit()
   
   # refresh each instance to access autogenerated fields
   for user in user_objects:
      db.refresh(user)
   
   return user_objects

# ========== BULK OPERATIONS FOR MULTIPLE INSERTIONS AND DELETIONS =============
def create_many_todos(db: Session, todos_data: List[schemas.ToDoCreate]) -> List[models.Todo]:
   """
   Bulk creates multiple todo items in the database.

   Args:
      db (Session): SQLAlchemy session object for database access.
      todos_data (List[ToDoCreate]): A list of Pydantic ToDoCreate models containing todo item data.

   
   Returns:
      List[models.Todo]: A list of created Todo model instances with updated fields (e.g., autogenerated IDs).
   
   Notes:
      This operation adds all the todo items to the session, commits the transaction, 
      and refreshes each item to reflect database-generated fields.
   """
   todo_items = [models.Todo(**todo.model_dump()) for todo in todos_data]
   db.add_all(todo_items)
   db.commit()
   
   # refresh each instance to access autogenerated fields
   for todo in todo_items:
      db.refresh(todo)
   
   return todo_items
